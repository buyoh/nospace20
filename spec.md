# spec

これらの仕様は、今後必ず変わります
TODO: テスト可能なドキュメントが良い

## 1 四則演算

```
2+3;
2 + 3;
2 - 3*5;
(2-3)*5;
3*4/(1+2);
```

リテラル: 直接コード上に記述する値のこと。`2`
式: `2+3`,
文: `2+3;`

## 2 組み込み識別子

```
__clog(5);
```

## 3 代入・変数定義

```
let:x; let:y; x=3; y=2; x=x+y; y=x+y;
```

- `let:x` は、識別子 x を定義して、スタックに領域を作成する。作成された領域は、スコープを抜けるまで有効である。
- どこで定義しても、スコープの先頭で定義されたものと同等になる。これは、javascript の巻き上げ (hoisting) と同等の動作である。
- (未実装) `final` 再代入不可。`const` リテラルのみ代入可かつ再代入不可。
- (未実装) 初期値。TODO: グローバルスコープに記述された初期値はいつ実行されるか？

```
a=5;  // not bad
let: a;
```

## 4 関数定義

```
func: pow(a) {
  __clog(a);
  return: a*a;
}

func: main() {
  let: x1; let: y1;
  let: x2; let: y2;
  x1 = 3; y1 = 4;
  x2 = 7; y2 = 3;
  __clog(pow(x2 - x1) + pow(y2 - y1));
  return: 0;
}
```

## 5 制御構文

```
func: main() {
  let:i;
  i=5;
  while:i{
    __clog(i);
    i=i-1;
  };
}
```

- if、 while は式であるため、末尾に`;`が必要。
- 式ではあるが、未実装のため、常に 0 を返す。

## 6 スコープ

```
func: main() {
  let:a;
  a = 1;
  if:1{
    let:b;
    a = 2;  // ok
    b = 3;  // ok
    // end of life of b
  };
  // b = 4;  // NG
}
```

- スコープは親子関係を持つ。親から子へはアクセスできない
- ブロックスコープと関数スコープがある。親の関数スコープにはアクセスできない
- グローバルスコープは関数スコープと同様。
- (未実装) static 変数は親の関数スコープにアクセス出来る。
  親の関数スコープで定義された関数にアクセス出来るのは、関数は static な定数として定義されるからである

```
func: fn1() {
  let: x1;
  fn4();  // ok (as hoisting)
  func: fn2() {
    let: x2;
    // x1 = 1;  // NG
    x2 = 1;  // ok
    func: fn2a() {
    }
  }
  func: fn4() {
    fn2();  // ok
    // fn2a();  // NG
  }
  // fn3();  // ok
  fn4();  // ok
  x1 = 1;  // ok
  // x2 = 1;  // NG
}
```

## a 型

未実装

- int
- void
- function
- tuple
